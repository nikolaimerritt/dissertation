\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Project Requirements}
In this section I describe the requirements that my project was to meet. These were decided on through discussions between myself and my supervisors. The requirements were based purely on the user functionality that the editor provides.
\\
\\
The editor must consist of three components to assist Logical English: a Syntax Highlighter, a Language Server and a Language Client. The syntax highlighter and language server must be cross-editor and cross-platform. This requirement meant that the editor can be used with many of the most popular programming editors on various operating systems with minimal configuration. Out of the three components, it is the language server that is the most complex.

\section{The Language Client}
The user uses the language client to interact with the features provided by the language server and syntax highlighter. Therefore, the language client must convey changes in the document to the syntax highlighter and language server. The language client must also incorporate the responses from the language server and syntax highlighter.

\section{The Syntax Highlighter}
The syntax highlighter must identify and label grammatical features in a Logical English given document. This must be done in a way that the language client can then use the labels to highlight the document. The syntax highlighter must identify both micro-features such as keywords and variable names, and macro-features such as section headers.

\section{The Language Server}
The language server must provide three functionalities to help the user write Logical English documents: code completion, error diagnostics, and suggested error fixes. 
\\ 
\\
These requirements were not concrete at the outset. After researching and explaining what is reasonably possible, these three requirements were agreed on through discussion between myself and my supervisors during the early to middle stages of creating the editor. 
\\
\\
My supervisors and I suggested that if there was time, after the above three features had been implemented, I could explore implementing a type-checking system in the editor.

\subsection{Code Completion}
When a user is in the process of writing an atomic formula, if the atomic formula could match a template, an option must appear for the editor to complete the remainder of the atomic formula according to the form of the matching template.

\subsection{Error Diagnostics}
The user must be informed if they make the following types of errors:
\begin{enumerate}
    \item a atomic formula has been written that does not match any template 
    \item a clause has been written where the precedence of the connectives has not been made clear by appropriate indentation
\end{enumerate}

\subsection{Suggested Error Fixes}
This feature was not a strict requirement, but was desirable. When the user writes a atomic formula that does not match a template, making error $(1)$ above, an option should appear for the editor to write a new template that matches the atomic formula. This feature is not required since it was not clear at the outset when it is possible to algorithmically generate such a template, nor how difficult such an algorithm would be to implement.

\section{The Type System and Type Checker}
\subsection{Requirements of the Type System}
The Logical English development team were considering introducing a type system. This type system would re-interpret the argument names of an atomic formula's template as the types of the values in the atomic formula. This type system would be used to check for inconsistent uses of values: errors where
\begin{itemize}
    \item an atomic formula contains a value $x$, where $x$ is assigned the type $A$
    \item another atomic formula contains the same value $x$, where $x$ is assigned the type $B$
    \item $A$ and $B$ are incompatible types.
\end{itemize}
I was tasked with specifying a suitable type system and implementing this type system in the editor. If finished, the editor would assign values their according types and notify the user when a type error was made. However, this feature was a suggestion, only to be explored if there was sufficient time once the other features had already been implemented. 
\end{document}
