\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Literature Review}
\section{Language Servers}
Language Servers have proven to be a powerful tool in creating cross-editor support for a wide variety of programming languages. As noted by Rask et al \cite[]{standardised_lsp_extensions}, the Language Server Protocol, which language servers use to communicate with code editors, ``changed the field of IDEs". This is because a language server can easily communicate with any IDE that supports the protocol, thus allowing IDEs to easily support a new language. Further, in surveying the effectiveness of language servers when building a language server for OCaml, Bour et al \cite[]{merlin_experience_report} note that ``adding support for a new editor to a language server requires no language-specific logic". This allows people who are not yet familiar with a given language to link a language server to their chosen editor that supports the Language Server Protocol, and begin programming in the editor. 
\\ \\
However, building a language server does not come without difficulties. Bour et al \cite[]{merlin_experience_report}, and the Visual Studio Code Language Server Extension documentation \cite[]{vsc_langserver_docs}, describe two main challenges that Language Servers face, that of ``incrementality" and ``partiality":
\begin{itemize}
    \item Due to effiency constraints, the IDE may only being able to send the portions of the document to the language server (incrementality)
    \item The language server has to parse incomplete portions of code that the user is writing (partiality)
\end{itemize}
In building their language server for OCaml, Bour et al solved these two issues by building their own parser, generated using an enhanced version of Menhir. This was needed because OCaml has a complex, recursive grammar, which made parsing incomplete portions of code a highly complex task. Logical English, however, has a simpler grammar; the only recursive feature that I will need to incorporate is that of modal atomic formulas. This makes it feasible for the language server to not need a separate, standalone parser. Instead, the language server will parse the document itself as and when needed.

\section{Editor Features}
There is also existing literature on boilerplate generation from existing code. Wang et al \cite[]{classless_java} created a powerful compilation agent that auto-generates Java boilerplate code from more succint, annotated Java. The boilerplate code is generated at the Abstract Syntax Tree (AST) level: the code generator starts with the AST representing the annotated code and, using the Lombok compilation agent, produces an AST corresponding to non-annotated, boilerplate Java. However, the recursive Logical English features from which I generate boilerplate code -- that of modal atomic formulas -- are much more constrained than the recursive features of Java. Thus I can favour a less complex representation over an AST.

\todo[inline]{Do background research on code auto-completion, code diagnosis and syntax highlighting}

\section{Type Systems}
Type systems are heavily documented

\end{document}