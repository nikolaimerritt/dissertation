\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Implementation}
%
%
%
\section{Semantic Highlighting}
\subsection{How a Language Server highlights}
\todo[inline]{Research this in more detail}

\subsection{Template Parsing}
First, the lines containing templates are found. These are found by starting after the header \codeword{the templates are:}, continuing until either another header or the end of the document is reached. A corresponding template is constructed from each non-empty line by the template class: sub-strings wrapped in asterisks are taken to contain types, and the relevant \codeword{Type} object is put in place, taken from the type tree.

\subsection{Extracting the terms of a literal}
The fundamental problem here is, given a template \codeword{T} and a literal \codeword{L} that is assumed to match, how to extract the elements of the literal? In short, this is done by leveraging the assumptions that the template and the literal share the same surroundings. Under this assumption, comparing the template's surroundings against the literal yields the literal's terms. The algorithm for this is given below.
\todo[inline]{Write up algorithm here}
This algorithm was constructed using the idea of incremental problem solving in my Algorithsm course.
There is a slight subtlety here: what happens if a surrounding also appears as a term. For example, a scenario where a merchant packages and sends items could be described with the template \codeword{*a merchant* ships *an item*}. If we have a merchant who packages and sends ships, then the corresponding literal would be \codeword{the merchant ships ships}.
\todo[inline]{Describe how this nuance is handled}
\todo[inline]{Talk about how this algorithm works with the edge case of incomplete literals also}

\subsection{Matching a template to a literal}
Once all the template representations have been created, the templates can be used to highlight the terms in each literal. Starting with a given literal, the templates are filtered by whether or not they match the literal. 
For each template, once the literal's elements have been extracted, the elements are checked to see whether they are isomorphic to the template's elements. That is, whether the surroundings match up between them.

\subsection{Finding the best match}
Old design: takes first template that matches. Problematic, especially with `default templates' e.g. ``*a thing* is *a thing*''
\\
New design with ranking \textit{partially written} templates according to how well they match
\\
\\
Initially, it was assumed that a literal can only match one template. As the editor was being developed, I soon saw how this was often false. This was most clearly visible when ``default'' templates were implemented -- general templates, such as \codeword{*a thing* is *a thing*} that were implicitly present in every Logical English document. With the above example, if a user then supplies a template \codeword{*a beneficiary* is included in *a will*}, then any literal that matches the latter template -- for example, \codeword{jane is a beneficiary of the will} -- will also match the former template. However, using the former template to extract terms will be incorrect, such as highlighting \codeword{a beneficiary of the will} as a single term.
\\ 
\\
This motivated a `match score' between a literal and a template. The higher the score, the better the template matches the literal, and the more certain we can be that it should be used to extract the terms.
\todo[inline]{Write up scoring algorithm}
\todo[inline]{Con: this is not normalised -- how are comparisons then meaningful?}
%
%
%
\section{Completion}
\subsection{How a language server completes code}
\todo[inline]{Research this in more detail}

\subsection{Completing the remainder of a literal}
To offer completion for a literal, first its corresponding templates are found. This is not as straightforward as searching for which templates match the literal, because the literal will be incomplete, and so will not match any template. Instead, the templates are ranked by their match score against the literal, and the top three are taken.
\\
\\
There is already some nuance here. Some matches will be ``obviously'' irrelevant, such as (the dreaded) \codeword{*a thing* is *a thing*} against \codeword{the person is a beneficiary of }. These cannot be ruled out algorithmically, however, since they do match. They will, however, be out-ranked by templates with better-matching surroundings, and will appear lower in the list.
Finding best three templates according to match score. Filling in templates with terms that the literal has so far.
\todo[inline]{Justify why at most three literals are suggested. Research user design.}
%
%
%
\section{Error diagnosis}
\subsection{How a language server diagnoses errors}
\todo[inline]{Research this in more detail}

\subsection{Diagnosing literals that have no matching template}
Given the above discussion it is fairly straightforward to find literals that do not match any template. The nuance is in using this as the deciding factor actually being too eager. Specifically, incomplete literals (e.g. literals that are being typed) will, in general, not match a template. This means that every literal that is being typed will be diagnosed as incorrect until it is finished.
\todo[inline]{Fix this in the code: do not suggest a diagnosis if the surrounding literal is where the cursor is.}

\subsection{Diagnosing clauses that have misaligned connectives}
This is another problem that sounds simple in theory, once the above framework was developed, but turned out to have nuances in practice. Each clause is split into its lines, and the lines containing the keywords \codeword{and} and \codeword{or}, which have equal precedence, have their indentation compared. If two literals with different connectives have the same whitespace, then the precedence of the connectives is ambiguous.
\\
\\
The nuance is with the term `same indentation'. There are two equally common ways to indent lines: tabs and spaces. There is no standard way to display a tab in terms of spaces: any range from two to eight spaces is common. Thus, if one person indents literals using tabs, and the other using spaces, then it is up to interpretation as to whether the indent is correct or not.
\todo[inline]{Cite sources on this. Talk about how this is a problem in Python, and that there is no solution. Talk about how it should therefore be an error to mix spaces and tabs, but I do not want to check for this.}
Issue: spaces versus tabs

\subsection{Diagnosing type mismatches}

\subsubsection{Feature Overview}

\subsubsection{Initial design: flat type hierarchy}
Problematic with default templates, e.g. `*a thing* is *a thing*'

\subsubsection{Diagnosing with a type hierarchy}
How a type hierarchy is written in LE
\\ 
How types are checked if they are compatible
%
%
%
\section{Quick Fixes}
\subsection{How a language server provides quick fixes}
\todo[inline]{Research this in more detail}

\subsection{Fixing a lack of template for literals}

\subsubsection{Feature Overview}
Explain and justify why a single template is generated from all template-less literals. 

\subsubsection{Template Generation using Least General Geneneralisation}

\subsubsection{Template Refinement from the re-use of terms}
Justify why this is done locally inside the clause.

\end{document}